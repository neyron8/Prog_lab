/*требуется для доступа к функциям ввода/вывода, а именно putchar(), printf() */
#include <stdio.h>
 
/*требуется для константного значения CHAR_BIT, в котором
 определено колличество бит на 1 байт*/
#include <limits.h>
 
/*прототипы функций, которые описаны ниже*/
void bit_print(int);
int pack(char, char, char, char);
 
/*функция печати числа в двоичном представлении, начиная со старшего байта*/
void bit_print(int a){
/*счетчик цикла*/
        int i;
 
/*считаем сколько бит содержится в типе int. sizeof() даст нам число байт.
умножаем число байт на число бит в байте и получаем число необходимое бит*/
        int n = sizeof(int) * CHAR_BIT;
 
/*устонавливаем маску для дальнейшей работы методом сдвига
нулевого бита (равного 1) на 31 позицию влево. Таким образом 31-й бит маски
равен 1, а все остальные равны 0*/
        int mask = 1 << (n-1); // mask = 100...0
 
/*запускаем цикл */
        for (i=1; i<=n; i++){
/*
1. сначала производится логическое И(авторы языка придумали термин "побитовое",
я разделяю их точку зрения) входного числа с маской. (помним что маска имеет только один бит с
единицей, а все остальные забиты нулями)
2. сравниваем полученный результат на эквивалентность нулю. Если да, то печатаем символ '0'
иначе печатаем символ '1'. Ну то есть печатаем значение, которое принимает 31-й бит входного числа
*/
                putchar(((a & mask) == 0)? '0' : '1');
 
/*сдвиг входного числа влево на 1 бит*/
                a <<= 1;
 
/*
НЕ ПО ТЕМЕ: теперь я догадался зачем используется это for (i=1; i<=n; i++)
ПО ТЕМЕ: если остаток от деления i на константу CHAR_BIT == 0 и итерация цикла не поледняя
то положить в поток пробел (напечатать)
*/
                if (i % CHAR_BIT == 0 && i < n)
                        putchar(' ');
        }
 
/*напечатать разрыв строки*/
        putchar('\n');
}
 
/*
функция для помещения четырех однобайтовых чисел в четыре байта четырехбайтового числа.
Реализована с прицелом на неоднозначность типа int, однако по умолчанию
подразумевает что int равен минимум 4 байтам
*/ 
int pack(char a, char b, char c, char d){
/*кладем первое число в младший байт переменной p*/
        int p=a;
/*сдвигаем влево число p на CHAR_BIT битов и кладем в младший
байт числа p байт b с помощью операции логического (побитового) ИЛИ
далее аналогично*/
        p = (p << CHAR_BIT) | b;
        p = (p << CHAR_BIT) | c;
        p = (p << CHAR_BIT) | d;
/*возвращаем полученное число*/
        return p;
}
 
int main(){
        
/*устанавливаем число p в соответствии со значением, которое вернет вызванная функция*/
        int p=pack('w', 'x', 'y', 'z');
        printf("\n'w', 'x', 'y', and 'z' packed together is equal to %d. Its binary rep. is:\n", p);
/*печать числа в двоичном формате*/
        bit_print(p);
        return 0;
}
